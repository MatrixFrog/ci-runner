<link rel="import" href="../components/core-collapse/core-collapse.html">
<link rel="import" href="../components/firebase-element/firebase-import.html">
<link rel="import" href="../components/polymer/polymer.html">

<link rel="import" href="shell-text.html">

<polymer-element name="log-entries">
  <template>
    <style>
      :host {
        display: block;
        margin: 1em 0 1em 1em;
      }

      .line {
        font: 13px 'Droid Sans Mono', 'Consolas', 'Source Sans Pro', 'Menlo', monospace;
      }

      .group {
        cursor: pointer;
        border-bottom: 1px solid #e0e0e0;
      }

      .warn {
        color: #e65100;
      }

      .error {
        color: #e51c23;
      }

      shell-text {
        display: block;
      }
    </style>

    <template id="entryTemplate">
      <shell-text id="{{id}}" text="{{entry.line}}" class="line {{entry.style}}"></shell-text>
    </template>

    <template id="groupTemplate">
      <core-collapse for="{{entryId}}" opened>
        <log-entries firebaseRoot="{{firebaseRoot}}"></log-entries>
      </core-collapse>
    </template>
  </template>

  <script>
    Polymer('log-entries', {
      publish: {
        // We DO NOT support changing this after `ready`!
        firebaseRoot: '',
        scrollsToBottom: false,
      },

      attached: function() {
        this._firebase = new Firebase(this.firebaseRoot);
        // Note that we assume that all entry text is immutable, and only ever
        // appended. Thus, no move tracking. Change tracking is only to detect
        // appearance of children.
        this._firebase.on('child_added',   this._onChildAdded.bind(this));
        this._firebase.on('child_changed', this._onChildChanged.bind(this));
        this._firebase.on('child_removed', this._onChildRemoved.bind(this));
      },

      detached: function() {
        this._firebase.off();
        this._firebase = null;
      },

      _onChildAdded: function(snapshot, prevEntryId) {
        var entryNode = this._stampEntryNode(snapshot);
        this._insertAfterEntry(entryNode, prevEntryId);

        if (snapshot.val().children) {
          this._insertAfterEntry(this._stampGroup(snapshot), snapshot.name());
        }

        this.fire('entry-added', entryNode);
      },

      _onChildChanged: function(snapshot) {
        var group = this._groupForId(snapshot.name());
        if (!snapshot.val().children || group) return;
        this._insertAfterEntry(this._stampGroup(snapshot), snapshot.name());
      },

      _onChildRemoved: function(snapshot) {
        this.shadowRoot.getElementById(snapshot.name()).remove();
        var group = this._groupForId(snapshot.name());
        if (group) group.remove();
      },

      _stampEntryNode: function(snapshot) {
        var model = {
          id:    snapshot.name(),
          entry: snapshot.val(),
        };
        var fragment = this.$.entryTemplate.createInstance(model, this.bindingDelegate);
        var node = fragment.children[0];

        Polymer.addEventListener(node, 'tap', this._onToggleChildren.bind(this));

        return node;
      },

      _stampGroup: function(snapshot) {
        var model = {
          entryId:      snapshot.name(),
          firebaseRoot: this.firebaseRoot + '/' + snapshot.name() + '/children',
        };
        var fragment = this.$.groupTemplate.createInstance(model, this.bindingDelegate);
        return fragment.children[0];
      },

      _onToggleChildren: function(event) {
        var group = this._groupForId(event.target.id);
        if (!group) return;
        group.toggle();
      },

      _groupForId: function(id) {
        return this.shadowRoot.querySelector('[for="' + id + '"]');
      },

      _insertAfterEntry: function(node, prevId) {
        var entryNode = this.shadowRoot.getElementById(prevId);
        if (!entryNode) {
          this.shadowRoot.appendChild(node);
          return;
        }

        if (entryNode.nextSibling && entryNode.nextSibling.getAttribute('for') == prevId) {
          // After the group
          this.shadowRoot.insertBefore(node, entryNode.nextSibling.nextSibling);
        } else {
          this.shadowRoot.insertBefore(node, entryNode.nextSibling);
        }
      }
    });
  </script>
</polymer-element>
